name: GitHub Organization Metrics

on:
  schedule:
    # Run every day at midnight
    - cron: '0 0 * * *'
  workflow_dispatch:
    # Allow manual trigger

jobs:
  collect-metrics:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Needed to push changes back to the repo
      pull-requests: read
      issues: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18

      - name: Install dependencies
        run: npm install octokit

      - name: Create data directory
        run: mkdir -p data

      - name: Create metrics collection script
        run: |
          cat > collect-metrics.mjs << 'EOF'
          import { Octokit } from 'octokit';
          import * as fs from 'fs';
          import * as path from 'path';

          // Configuration
          const ORG_NAME = process.env.ORGANIZATION || 'OmniCloudOrg';
          const TOKEN = process.env.GITHUB_TOKEN;
          const OUTPUT_DIR = path.join(process.cwd(), 'data');
          const OUTPUT_FILE = path.join(OUTPUT_DIR, 'github-metrics.json');
          const HISTORY_FILE = path.join(OUTPUT_DIR, 'metrics-history.json');

          // Initialize GitHub client with auth token
          const octokit = new Octokit({
            auth: TOKEN,
          });

          // Language factors for estimating lines of code
          const LANGUAGE_FACTORS = {
            'JavaScript': 0.05,  // ~20 bytes per line
            'TypeScript': 0.05,
            'Python': 0.08,      // ~12 bytes per line
            'Java': 0.04,        // ~25 bytes per line
            'C#': 0.04,
            'Go': 0.06,
            'Ruby': 0.07,
            'PHP': 0.05,
            'C++': 0.04,
            'C': 0.05,
            'HTML': 0.02,        // ~50 bytes per line
            'CSS': 0.03,
            'Shell': 0.1,
            'Markdown': 0.1,
            'JSON': 0.01,        // ~100 bytes per line
            'YAML': 0.08,
            'default': 0.05
          };

          // Utility function to handle pagination
          async function getAllItems(method, params = {}) {
            const items = [];
            let page = 1;
            let hasNextPage = true;

            while (hasNextPage) {
              try {
                const response = await method({
                  ...params,
                  page,
                  per_page: 100
                });

                const data = response.data;
                items.push(...data);

                // Check if there are more pages
                hasNextPage = data.length === 100;
                page++;

                // Safety limit to prevent infinite loops
                if (page > 10) {
                  console.warn('Reached pagination limit (10 pages), some data may be incomplete');
                  break;
                }

                // Add a small delay to avoid hitting rate limits
                if (hasNextPage) {
                  await new Promise(resolve => setTimeout(resolve, 500));
                }
              } catch (error) {
                console.error(`Error fetching page ${page}:`, error.message);
                break;
              }
            }

            return items;
          }

          // Extract co-authors from commit messages
          function extractCoAuthors(message) {
            if (!message) return [];

            const coauthors = [];
            
            // Match various co-author formats
            const patterns = [
              /co[\-\s]authored[\-\s]by:[\s\n]+([^<\n]+?)[\s\n]*<([^>\n]+)>/gi,
              /co-author:[\s\n]+([^<\n]+?)[\s\n]*<([^>\n]+)>/gi
            ];
            
            for (const pattern of patterns) {
              const matches = [...message.matchAll(pattern)];
              for (const match of matches) {
                coauthors.push({
                  name: match[1].trim(),
                  email: match[2].trim()
                });
              }
            }
            
            return coauthors;
          }

          // Extract username from GitHub email
          function getUsernameFromEmail(email, name) {
            // Handle GitHub noreply email format: ID+username@users.noreply.github.com
            const githubNoReplyRegex = /^(\d+)\+(.+)@users\.noreply\.github\.com$/i;
            const githubMatch = email.match(githubNoReplyRegex);
            
            if (githubMatch && githubMatch[2]) {
              return githubMatch[2];
            }
            
            // Check other GitHub email formats
            if (email.endsWith('@github.com')) {
              return email.split('@')[0];
            }
            
            if (email.endsWith('@users.github.com') || 
                (email.endsWith('@users.noreply.github.com') && !email.includes('+'))) {
              return email.split('@')[0];
            }
            
            // Check if name contains a GitHub username format
            if (name) {
              const usernameInName = name.match(/@([a-zA-Z0-9\-]+)/);
              if (usernameInName && usernameInName[1]) {
                return usernameInName[1];
              }
            }
            
            // Extract username from email
            const emailUsername = email.split('@')[0];
            if (emailUsername && emailUsername.length > 2 && !/^\d+$/.test(emailUsername)) {
              return emailUsername;
            }
            
            // Use cleaned name as fallback
            if (name) {
              return name.toLowerCase().replace(/[^a-z0-9]/g, '');
            }
            
            return null;
          }

          // Main function to collect metrics
          async function collectMetrics() {
            console.log(`Starting metrics collection for ${ORG_NAME}...`);
            const startTime = Date.now();
            
            try {
              // Create output directory if it doesn't exist
              if (!fs.existsSync(OUTPUT_DIR)) {
                fs.mkdirSync(OUTPUT_DIR, { recursive: true });
              }

              // Get all repositories
              console.log(`Fetching repositories for ${ORG_NAME}...`);
              const allRepos = await getAllItems(
                octokit.rest.repos.listForOrg,
                { org: ORG_NAME, sort: 'updated', direction: 'desc' }
              );
              
              console.log(`Found ${allRepos.length} repositories`);
              
              // Initialize metrics object
              const metrics = {
                organization: ORG_NAME,
                timestamp: new Date().toISOString(),
                stats: {
                  repositories: allRepos.length,
                  stars: 0,
                  forks: 0,
                  watchers: 0,
                  openIssues: 0,
                  totalCommits: 0,
                  linesOfCode: 0,
                  contributors: {
                    total: 0,
                    top: []
                  },
                  languages: {}
                },
                repositories: []
              };
              
              // Track contributors across all repos
              const contributorsMap = new Map();
              
              // Process repositories
              console.log('Processing repositories...');
              const MAX_BATCH_SIZE = 3; // Process repos in batches to avoid rate limits
              
              for (let i = 0; i < allRepos.length; i += MAX_BATCH_SIZE) {
                const batch = allRepos.slice(i, i + MAX_BATCH_SIZE);
                
                await Promise.all(batch.map(async (repo) => {
                  console.log(`Processing ${repo.name}...`);
                  
                  // Add basic stats to totals
                  metrics.stats.stars += repo.stargazers_count || 0;
                  metrics.stats.forks += repo.forks_count || 0;
                  metrics.stats.watchers += repo.watchers_count || 0;
                  metrics.stats.openIssues += repo.open_issues_count || 0;
                  
                  const repoMetrics = {
                    name: repo.name,
                    description: repo.description,
                    url: repo.html_url,
                    stars: repo.stargazers_count || 0,
                    forks: repo.forks_count || 0,
                    watchers: repo.watchers_count || 0,
                    openIssues: repo.open_issues_count || 0,
                    languages: {},
                    linesOfCode: 0,
                    commits: 0,
                    contributors: 0
                  };
                  
                  try {
                    // Get language breakdown
                    const languages = await octokit.rest.repos.listLanguages({
                      owner: ORG_NAME,
                      repo: repo.name
                    });
                    
                    repoMetrics.languages = languages.data;
                    
                    // Calculate lines of code
                    let repoLines = 0;
                    for (const [language, bytes] of Object.entries(languages.data)) {
                      const factor = LANGUAGE_FACTORS[language] || LANGUAGE_FACTORS.default;
                      const lines = Math.round(bytes * factor);
                      repoLines += lines;
                      
                      // Add to global language stats
                      if (!metrics.stats.languages[language]) {
                        metrics.stats.languages[language] = 0;
                      }
                      metrics.stats.languages[language] += bytes;
                    }
                    
                    repoMetrics.linesOfCode = repoLines;
                    metrics.stats.linesOfCode += repoLines;
                    
                    // Get number of commits
                    const commitsResponse = await octokit.rest.repos.listCommits({
                      owner: ORG_NAME,
                      repo: repo.name,
                      per_page: 1
                    });
                    
                    // If there's a Link header with last page, use it to get total count
                    const linkHeader = commitsResponse.headers.link;
                    if (linkHeader && linkHeader.includes('rel="last"')) {
                      const match = linkHeader.match(/page=(\d+)>; rel="last"/);
                      if (match) {
                        const totalCommits = parseInt(match[1], 10);
                        repoMetrics.commits = totalCommits;
                        metrics.stats.totalCommits += totalCommits;
                      }
                    } else {
                      // Otherwise, fetch all commits
                      const allCommits = await getAllItems(
                        octokit.rest.repos.listCommits,
                        { owner: ORG_NAME, repo: repo.name }
                      );
                      repoMetrics.commits = allCommits.length;
                      metrics.stats.totalCommits += allCommits.length;
                      
                      // Process commits for co-authors
                      console.log(`  Checking ${allCommits.length} commits for co-authors...`);
                      for (const commit of allCommits) {
                        if (!commit.commit?.message) continue;
                        
                        // Process commit authors
                        if (commit.author && commit.author.login) {
                          const authorLogin = commit.author.login.toLowerCase();
                          if (!contributorsMap.has(authorLogin)) {
                            contributorsMap.set(authorLogin, {
                              login: commit.author.login,
                              avatar_url: commit.author.avatar_url,
                              html_url: commit.author.html_url,
                              contributions: 0,
                              lines_contributed: 0,
                              repositories: new Set()
                            });
                          }
                          
                          const contributor = contributorsMap.get(authorLogin);
                          contributor.contributions += 1;
                          contributor.repositories.add(repo.name);
                        }
                        
                        // Process co-authors in commit message
                        const coAuthors = extractCoAuthors(commit.commit.message);
                        for (const { name, email } of coAuthors) {
                          const username = getUsernameFromEmail(email, name);
                          if (!username) continue;
                          
                          const normalizedUsername = username.toLowerCase();
                          if (!contributorsMap.has(normalizedUsername)) {
                            contributorsMap.set(normalizedUsername, {
                              login: username,
                              avatar_url: `https://github.com/${username}.png`,
                              html_url: `https://github.com/${username}`,
                              contributions: 0,
                              lines_contributed: 0,
                              repositories: new Set()
                            });
                          }
                          
                          const contributor = contributorsMap.get(normalizedUsername);
                          contributor.contributions += 1;
                          contributor.repositories.add(repo.name);
                        }
                      }
                    }
                    
                    // Get contributors count
                    const contributors = await getAllItems(
                      octokit.rest.repos.listContributors,
                      { owner: ORG_NAME, repo: repo.name }
                    );
                    
                    repoMetrics.contributors = contributors.length;
                    
                    // Process each contributor
                    for (const contributor of contributors) {
                      if (!contributor.login) continue;
                      
                      const normalizedLogin = contributor.login.toLowerCase();
                      if (!contributorsMap.has(normalizedLogin)) {
                        contributorsMap.set(normalizedLogin, {
                          login: contributor.login,
                          avatar_url: contributor.avatar_url,
                          html_url: contributor.html_url,
                          contributions: 0,
                          lines_contributed: 0,
                          repositories: new Set()
                        });
                      }
                      
                      const existingContributor = contributorsMap.get(normalizedLogin);
                      existingContributor.contributions += contributor.contributions;
                      existingContributor.repositories.add(repo.name);
                      
                      // Estimate lines contributed based on proportion of commits
                      const contributionRatio = contributor.contributions / Math.max(repoMetrics.commits, 1);
                      const estimatedLines = Math.round(repoLines * contributionRatio);
                      existingContributor.lines_contributed += estimatedLines;
                    }
                    
                  } catch (error) {
                    console.error(`  Error processing ${repo.name}:`, error.message);
                  }
                  
                  metrics.repositories.push(repoMetrics);
                }));
                
                // Add small delay between batches
                if (i + MAX_BATCH_SIZE < allRepos.length) {
                  await new Promise(resolve => setTimeout(resolve, 1000));
                }
              }
              
              // Convert contributors map to array and sort by contributions
              const allContributors = Array.from(contributorsMap.values())
                .map(c => ({
                  ...c,
                  repositories: Array.from(c.repositories)
                }))
                .sort((a, b) => b.contributions - a.contributions);
              
              metrics.stats.contributors.total = allContributors.length;
              metrics.stats.contributors.top = allContributors.slice(0, 10);
              
              console.log(`Found ${allContributors.length} unique contributors`);
              console.log(`Total commits: ${metrics.stats.totalCommits}`);
              console.log(`Total lines of code: ${metrics.stats.linesOfCode}`);
              
              // Save metrics to file
              console.log(`Saving metrics to ${OUTPUT_FILE}...`);
              fs.writeFileSync(OUTPUT_FILE, JSON.stringify(metrics, null, 2));
              
              // Update history
              let history = [];
              if (fs.existsSync(HISTORY_FILE)) {
                try {
                  history = JSON.parse(fs.readFileSync(HISTORY_FILE, 'utf8'));
                } catch (error) {
                  console.warn('Error reading history file, starting fresh:', error.message);
                }
              }
              
              history.push({
                timestamp: metrics.timestamp,
                repositories: metrics.stats.repositories,
                stars: metrics.stats.stars,
                forks: metrics.stats.forks,
                contributors: metrics.stats.contributors.total,
                commits: metrics.stats.totalCommits,
                linesOfCode: metrics.stats.linesOfCode
              });
              
              // Keep history to reasonable size
              if (history.length > 100) {
                history = history.slice(-100);
              }
              
              fs.writeFileSync(HISTORY_FILE, JSON.stringify(history, null, 2));
              console.log(`Updated metrics history in ${HISTORY_FILE}`);
              
              const duration = (Date.now() - startTime) / 1000;
              console.log(`âœ… Metrics collection completed in ${duration.toFixed(2)}s`);
              
            } catch (error) {
              console.error('Error collecting metrics:', error);
              process.exit(1);
            }
          }

          // Run the metrics collection
          collectMetrics();
          EOF

      - name: Collect GitHub Metrics
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ORGANIZATION: 'OmniCloudOrg'  # Replace with your organization name
        run: node collect-metrics.mjs

      - name: Commit and push if changed
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add data/
          git commit -m "Update GitHub metrics [skip ci]" || exit 0
          git push
